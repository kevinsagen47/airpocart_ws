# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from teco_msgs/battery_srvRequest.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class battery_srvRequest(genpy.Message):
  _md5sum = "39e92f1778057359c64c7b8a7d7b19de"
  _type = "teco_msgs/battery_srvRequest"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """string input
"""
  __slots__ = ['input']
  _slot_types = ['string']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       input

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(battery_srvRequest, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.input is None:
        self.input = ''
    else:
      self.input = ''

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self.input
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.input = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.input = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self.input
      length = len(_x)
      if python3 or type(_x) == unicode:
        _x = _x.encode('utf-8')
        length = len(_x)
      buff.write(struct.Struct('<I%ss'%length).pack(length, _x))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      start = end
      end += 4
      (length,) = _struct_I.unpack(str[start:end])
      start = end
      end += length
      if python3:
        self.input = str[start:end].decode('utf-8', 'rosmsg')
      else:
        self.input = str[start:end]
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from teco_msgs/battery_srvResponse.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class battery_srvResponse(genpy.Message):
  _md5sum = "f76442e7ca355905447f2ebc796d5598"
  _type = "teco_msgs/battery_srvResponse"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """float32 PackageVoltage
float32 PackageCurrent

float32 SOHP
float32 SOCP
float32 AHCnow
float32 AHCmax

float32 CurrentSensorValue1
float32 CurrentSensorValue2

float32 TemperaturePack

float32 CellTemperature1
float32 CellTemperature2
float32 CellTemperature3
float32 CellTemperature4

float32 CellTemperature5
float32 CellTemperature6
float32 CellTemperature7

float32 CellVoltage1
float32 CellVoltage2
float32 CellVoltage3
float32 CellVoltage4

float32 CellVoltage5
float32 CellVoltage6
float32 CellVoltage7

float32 CellSOC1
float32 CellSOC2
float32 CellSOC3
float32 CellSOC4

float32 CellSOC5
float32 CellSOC6
float32 CellSOC7

float32 CellSOH1
float32 CellSOH2
float32 CellSOH3
float32 CellSOH4

float32 CellSOH5
float32 CellSOH6
float32 CellSOH7

"""
  __slots__ = ['PackageVoltage','PackageCurrent','SOHP','SOCP','AHCnow','AHCmax','CurrentSensorValue1','CurrentSensorValue2','TemperaturePack','CellTemperature1','CellTemperature2','CellTemperature3','CellTemperature4','CellTemperature5','CellTemperature6','CellTemperature7','CellVoltage1','CellVoltage2','CellVoltage3','CellVoltage4','CellVoltage5','CellVoltage6','CellVoltage7','CellSOC1','CellSOC2','CellSOC3','CellSOC4','CellSOC5','CellSOC6','CellSOC7','CellSOH1','CellSOH2','CellSOH3','CellSOH4','CellSOH5','CellSOH6','CellSOH7']
  _slot_types = ['float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32','float32']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       PackageVoltage,PackageCurrent,SOHP,SOCP,AHCnow,AHCmax,CurrentSensorValue1,CurrentSensorValue2,TemperaturePack,CellTemperature1,CellTemperature2,CellTemperature3,CellTemperature4,CellTemperature5,CellTemperature6,CellTemperature7,CellVoltage1,CellVoltage2,CellVoltage3,CellVoltage4,CellVoltage5,CellVoltage6,CellVoltage7,CellSOC1,CellSOC2,CellSOC3,CellSOC4,CellSOC5,CellSOC6,CellSOC7,CellSOH1,CellSOH2,CellSOH3,CellSOH4,CellSOH5,CellSOH6,CellSOH7

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(battery_srvResponse, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.PackageVoltage is None:
        self.PackageVoltage = 0.
      if self.PackageCurrent is None:
        self.PackageCurrent = 0.
      if self.SOHP is None:
        self.SOHP = 0.
      if self.SOCP is None:
        self.SOCP = 0.
      if self.AHCnow is None:
        self.AHCnow = 0.
      if self.AHCmax is None:
        self.AHCmax = 0.
      if self.CurrentSensorValue1 is None:
        self.CurrentSensorValue1 = 0.
      if self.CurrentSensorValue2 is None:
        self.CurrentSensorValue2 = 0.
      if self.TemperaturePack is None:
        self.TemperaturePack = 0.
      if self.CellTemperature1 is None:
        self.CellTemperature1 = 0.
      if self.CellTemperature2 is None:
        self.CellTemperature2 = 0.
      if self.CellTemperature3 is None:
        self.CellTemperature3 = 0.
      if self.CellTemperature4 is None:
        self.CellTemperature4 = 0.
      if self.CellTemperature5 is None:
        self.CellTemperature5 = 0.
      if self.CellTemperature6 is None:
        self.CellTemperature6 = 0.
      if self.CellTemperature7 is None:
        self.CellTemperature7 = 0.
      if self.CellVoltage1 is None:
        self.CellVoltage1 = 0.
      if self.CellVoltage2 is None:
        self.CellVoltage2 = 0.
      if self.CellVoltage3 is None:
        self.CellVoltage3 = 0.
      if self.CellVoltage4 is None:
        self.CellVoltage4 = 0.
      if self.CellVoltage5 is None:
        self.CellVoltage5 = 0.
      if self.CellVoltage6 is None:
        self.CellVoltage6 = 0.
      if self.CellVoltage7 is None:
        self.CellVoltage7 = 0.
      if self.CellSOC1 is None:
        self.CellSOC1 = 0.
      if self.CellSOC2 is None:
        self.CellSOC2 = 0.
      if self.CellSOC3 is None:
        self.CellSOC3 = 0.
      if self.CellSOC4 is None:
        self.CellSOC4 = 0.
      if self.CellSOC5 is None:
        self.CellSOC5 = 0.
      if self.CellSOC6 is None:
        self.CellSOC6 = 0.
      if self.CellSOC7 is None:
        self.CellSOC7 = 0.
      if self.CellSOH1 is None:
        self.CellSOH1 = 0.
      if self.CellSOH2 is None:
        self.CellSOH2 = 0.
      if self.CellSOH3 is None:
        self.CellSOH3 = 0.
      if self.CellSOH4 is None:
        self.CellSOH4 = 0.
      if self.CellSOH5 is None:
        self.CellSOH5 = 0.
      if self.CellSOH6 is None:
        self.CellSOH6 = 0.
      if self.CellSOH7 is None:
        self.CellSOH7 = 0.
    else:
      self.PackageVoltage = 0.
      self.PackageCurrent = 0.
      self.SOHP = 0.
      self.SOCP = 0.
      self.AHCnow = 0.
      self.AHCmax = 0.
      self.CurrentSensorValue1 = 0.
      self.CurrentSensorValue2 = 0.
      self.TemperaturePack = 0.
      self.CellTemperature1 = 0.
      self.CellTemperature2 = 0.
      self.CellTemperature3 = 0.
      self.CellTemperature4 = 0.
      self.CellTemperature5 = 0.
      self.CellTemperature6 = 0.
      self.CellTemperature7 = 0.
      self.CellVoltage1 = 0.
      self.CellVoltage2 = 0.
      self.CellVoltage3 = 0.
      self.CellVoltage4 = 0.
      self.CellVoltage5 = 0.
      self.CellVoltage6 = 0.
      self.CellVoltage7 = 0.
      self.CellSOC1 = 0.
      self.CellSOC2 = 0.
      self.CellSOC3 = 0.
      self.CellSOC4 = 0.
      self.CellSOC5 = 0.
      self.CellSOC6 = 0.
      self.CellSOC7 = 0.
      self.CellSOH1 = 0.
      self.CellSOH2 = 0.
      self.CellSOH3 = 0.
      self.CellSOH4 = 0.
      self.CellSOH5 = 0.
      self.CellSOH6 = 0.
      self.CellSOH7 = 0.

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_37f().pack(_x.PackageVoltage, _x.PackageCurrent, _x.SOHP, _x.SOCP, _x.AHCnow, _x.AHCmax, _x.CurrentSensorValue1, _x.CurrentSensorValue2, _x.TemperaturePack, _x.CellTemperature1, _x.CellTemperature2, _x.CellTemperature3, _x.CellTemperature4, _x.CellTemperature5, _x.CellTemperature6, _x.CellTemperature7, _x.CellVoltage1, _x.CellVoltage2, _x.CellVoltage3, _x.CellVoltage4, _x.CellVoltage5, _x.CellVoltage6, _x.CellVoltage7, _x.CellSOC1, _x.CellSOC2, _x.CellSOC3, _x.CellSOC4, _x.CellSOC5, _x.CellSOC6, _x.CellSOC7, _x.CellSOH1, _x.CellSOH2, _x.CellSOH3, _x.CellSOH4, _x.CellSOH5, _x.CellSOH6, _x.CellSOH7))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 148
      (_x.PackageVoltage, _x.PackageCurrent, _x.SOHP, _x.SOCP, _x.AHCnow, _x.AHCmax, _x.CurrentSensorValue1, _x.CurrentSensorValue2, _x.TemperaturePack, _x.CellTemperature1, _x.CellTemperature2, _x.CellTemperature3, _x.CellTemperature4, _x.CellTemperature5, _x.CellTemperature6, _x.CellTemperature7, _x.CellVoltage1, _x.CellVoltage2, _x.CellVoltage3, _x.CellVoltage4, _x.CellVoltage5, _x.CellVoltage6, _x.CellVoltage7, _x.CellSOC1, _x.CellSOC2, _x.CellSOC3, _x.CellSOC4, _x.CellSOC5, _x.CellSOC6, _x.CellSOC7, _x.CellSOH1, _x.CellSOH2, _x.CellSOH3, _x.CellSOH4, _x.CellSOH5, _x.CellSOH6, _x.CellSOH7,) = _get_struct_37f().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_37f().pack(_x.PackageVoltage, _x.PackageCurrent, _x.SOHP, _x.SOCP, _x.AHCnow, _x.AHCmax, _x.CurrentSensorValue1, _x.CurrentSensorValue2, _x.TemperaturePack, _x.CellTemperature1, _x.CellTemperature2, _x.CellTemperature3, _x.CellTemperature4, _x.CellTemperature5, _x.CellTemperature6, _x.CellTemperature7, _x.CellVoltage1, _x.CellVoltage2, _x.CellVoltage3, _x.CellVoltage4, _x.CellVoltage5, _x.CellVoltage6, _x.CellVoltage7, _x.CellSOC1, _x.CellSOC2, _x.CellSOC3, _x.CellSOC4, _x.CellSOC5, _x.CellSOC6, _x.CellSOC7, _x.CellSOH1, _x.CellSOH2, _x.CellSOH3, _x.CellSOH4, _x.CellSOH5, _x.CellSOH6, _x.CellSOH7))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 148
      (_x.PackageVoltage, _x.PackageCurrent, _x.SOHP, _x.SOCP, _x.AHCnow, _x.AHCmax, _x.CurrentSensorValue1, _x.CurrentSensorValue2, _x.TemperaturePack, _x.CellTemperature1, _x.CellTemperature2, _x.CellTemperature3, _x.CellTemperature4, _x.CellTemperature5, _x.CellTemperature6, _x.CellTemperature7, _x.CellVoltage1, _x.CellVoltage2, _x.CellVoltage3, _x.CellVoltage4, _x.CellVoltage5, _x.CellVoltage6, _x.CellVoltage7, _x.CellSOC1, _x.CellSOC2, _x.CellSOC3, _x.CellSOC4, _x.CellSOC5, _x.CellSOC6, _x.CellSOC7, _x.CellSOH1, _x.CellSOH2, _x.CellSOH3, _x.CellSOH4, _x.CellSOH5, _x.CellSOH6, _x.CellSOH7,) = _get_struct_37f().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_37f = None
def _get_struct_37f():
    global _struct_37f
    if _struct_37f is None:
        _struct_37f = struct.Struct("<37f")
    return _struct_37f
class battery_srv(object):
  _type          = 'teco_msgs/battery_srv'
  _md5sum = 'c8b59f64747d119147a5ffdefffd3858'
  _request_class  = battery_srvRequest
  _response_class = battery_srvResponse
